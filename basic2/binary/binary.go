package main

import "fmt"

// 二进制计算
// 在计算机内部，进行各种运算时，都是以二进制的方式来进行的

// 二进制 八进制 十进制 十六进制之间的相互转换
// 二进制的 原码 反码 补码
// 1.二进制的最高位是符号位：0表示正数 1表示负数
// 2.正数的原码 反码 补码都是一样的
// 3.负数的反码=它的原码的符号位不变，其它位取反(0->1 1->0)
// 4.负数的补码=它的反码+1
// 5.0的反码 补码都是0
// 6.在计算机运算的时候，都是以补码来进行运算的

// 示例如下：
// 十进制数 2 的原码 0000 0010  反码 0000 0010  补码 0000 0010
// 十进制数-2 的原码 1000 0010  反码 1111 1101  补码 1111 1110

// 二进制运算符：
// & (位运算符)：按位与 - 两位全为1 结果为1，否则为0
// | (位运算符)：按位或 - 两位至少有一个为1 结果为1，否则为0
// ^ (位运算符)：按位异或 - 两位一个为1 一个为0，则结果为1，否则为0
// >> (移位运算符)：右移 - 低位溢出，符号位不变，并用符号位补溢出的高位
// << (移位运算符)：左移 - 符号位不变，低位补0

// 示例如下：
/**
计算 1&2 = ?
先转换出对应的补码
十进制 1 -> 原码 0000 0001 -> 反码 0000 0001 -> 补码 0000 0001
十进制 2 -> 原码 0000 0010 -> 反码 0000 0010 -> 补码 0000 0010

用它们的补码来进行"&"运算
   0000 0001
   0000 0010
&  0000 0000
与运算得到的结果也是一个补码，因为符号位是0 所以是正数，所以补码=原码 即原码是0000 0000 转换成十进制则是 0
所以 1&2 = 0
 */

/**
计算 2^-2 = ?
先转换出对应的补码
十进制 2  -> 原码 0000 0010 -> 反码 0000 0010 -> 补码 0000 0010
十进制 -2 -> 原码 1000 0010 -> 反码 1111 1101 -> 补码 1111 1110

用它们的补码来进行"^"运算
    0000 0010
    1111 1110
^   1111 1100
异或运算得到的结果也是一个补码，因为符号位是1 所以是负数,故将补码反转为原码：
补码 1111 1100 -> 反码 1111 1011 -> 原码 1000 0100  转换成十进制则是 -4
所以 2^-2 = -4
 */

/**
计算 -2 >> 2 = ?
先转换出对应的补码
十进制 -2 -> 原码 1000 0010 -> 反码 1111 1101 -> 补码 1111 1110

再对其补码进行"右移位运算" >>2
1111 1110 -> 1__1 1111 -> 1111 1111

移位运算得到的结果也是一个补码，因为符号位是1 所以是负数,故将补码反转为原码：
补码 1111 1111 -> 反码 1111 1110 -> 原码 1000 0001  转换成十进制则是 -1
所以 -2 >> 2 = -1
 */

func main() {
	fmt.Println(1&2)
	fmt.Println(2^-2)
	fmt.Println(-2 >> 2)
}
