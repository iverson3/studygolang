Goroutine协程的特点：
1. 有独立的栈空间
2. 共享程序的堆空间
3. 调度由用户控制
4. 协程可以看作是轻量级的线程


go的主线程是一个物理线程，直接作用在cpu上，是重量级的，比较耗费cpu资源
协程是从主线程中开启的，是类似于轻量级的线程，是逻辑态的，对资源消耗很少
其他编程语言中的并发机制一般都是基于线程的，开启的线程过多，会导致系统资源消耗过大


多线程程序在单核(cpu)上运行，就是并发
多线程程序在多核(cpu)上运行，就是并行

并发： 多个线程运行在同一个cpu上，宏观上这些线程是同时运行的，但微观上并不是同时运行的，而是在不断的切换着交替运行
并行： 多个线程运行在多个cpu上(多核cpu机器)，宏观和微观上 这些线程都是同时在运行的



Go G-P-M模型

G - 表示 Goroutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能被调度执行。
P - Processor，表示逻辑处理器，对G来说，P相当于CPU核，G只有绑定到P(在 P 的 local runq 中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量（前提：物理 CPU 核数 >= P 的数量）
M - Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个。


go1.8版本前，要显示的设置可使用的cpu数，才能更高效的利用多核cpu
go1.8版本后，默认程序就是运行在多cpu上，不需要进行显示的设置



** channel **

channel本质就是一个队列
数据遵循先进先出的原则
线程安全，多个goroutine同时访问时，不需要自己加锁，因为channel本身就是线程安全的 (channel的底层实现已经进行了加锁处理)
channel是有类型的，比如一个string类型的channel只能传输string类型的数据


goroutine之间的双向通道就是channel
go slogan: 不要通过共享内存来通信, 要通过通信来共享内存

channel是一等公民 可以作为参数或返回值 (channel是引用类型)
make(chan Type, capacity) 指定缓冲区容量 (必须用make()进行初始化分配内存后才能使用)
不使用缓冲区容量，那么该通道就是同步的，因此会阻塞直到接收者与发送者都做好准备；指定缓冲区容量，那么该通道是异步的。

chan<- int   该channel只能发数据 (向channel里面发数据)
<-chan int   该channel只能收数据 (从channel里面收数据)