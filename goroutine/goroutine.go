package main

import (
	"fmt"
	"runtime"
	"time"
)

// 协程 Coroutine

// 协程是轻量级的"线程"
// 协程是非抢占式的多任务处理 由协程主动交出控制权 (操作系统不会强制性的抢走控制权)
// 协程是编译器/解释器/虚拟机层面的多任务 (线程是操作系统层面的多任务)
// 多个协程可以在一个或多个线程上运行 (go有调度器进行协程的调度)

// 子程序(普通的函数调用)是协程的一个特例

// 任何函数只要在前面加上go关键字 就变成了一个协程 并送给调度器去运行 (不需要在定义时区分是否是异步函数)
// 调度器在合适的点进行协程之间的切换
// 使用-race可以检测数据访问的冲突, 比如多个协程同时去读写某个变量 (go run -race test.go)

// goroutine 可能的切换点：
// IO操作(比如Print 读写文件)  select   channel   等待锁   函数调用(不一定)   runtime.Gosched()
// 以上的切换点只是参考,并不能保证在这些点一定会切换，也不能保证在其他地方不会切换

func main() {
	var a [10]int
	for i := 0; i < 10; i++ {
		// 循环开了100个协程
		go func(i int) {
			for {
				// Print属于io操作 io操作会有等待, 于是可能会交出协程的控制权
				//fmt.Printf("Hello from goroutine %d\n", i)

				// 协程是非抢占式的，它在执行的过程中 需要自己主动交出控制权
				// 如果协程在执行过程中没有主动交出控制权的操作，那么该协程会一直执行下去 最终可能奔溃
				a[i]++
				// 手动交出协程的控制权
				runtime.Gosched()
			}
		}(i)
	}
	// 让主程序睡眠一段时间, 给goroutine协程一定的时间来执行并输出
	// 如果没有睡眠 主程序执行结束,main函数退出 则打开的所有协程都会被kill掉 整个程序结束
	time.Sleep(time.Millisecond * 50)

	fmt.Println(a)
}



















